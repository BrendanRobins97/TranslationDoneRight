This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-08T23:36:33.797Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
ExampleScript.cs
ExampleScript.cs.meta
ExampleScriptableObject.asset
ExampleScriptableObject.asset.meta
ExampleScriptableObject.cs
ExampleScriptableObject.cs.meta
local-research.meta
local-research/localization-features.md
local-research/localization-features.md.meta
Test.prefab
Test.prefab.meta
Translations.meta
Translations/Editor.meta
Translations/Editor/TranslationsEditorWindow.cs
Translations/Editor/TranslationsEditorWindow.cs.meta
Translations/LanguageData.cs
Translations/LanguageData.cs.meta
Translations/PSS.Translations.asmdef
Translations/PSS.Translations.asmdef.meta
Translations/TextExtractor.cs
Translations/TextExtractor.cs.meta
Translations/TranslatedAttribute.cs
Translations/TranslatedAttribute.cs.meta
Translations/TranslationData.cs
Translations/TranslationData.cs.meta
Translations/TranslationManager.cs
Translations/TranslationManager.cs.meta
Translations/Translations.cs
Translations/Translations.cs.meta
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Unity generated
[Ll]ibrary/
[Tt]emp/
[Oo]bj/
[Bb]uild/
[Bb]uilds/
[Ll]ogs/
[Uu]ser[Ss]ettings/

# Never ignore Asset meta data
!/[Aa]ssets/**/*.meta

# Visual Studio / VS Code
.vs/
.vscode/
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.mdb
*.opendb
*.VC.db

# Unity3D generated meta files
*.pidb.meta
*.pdb.meta
*.mdb.meta

# Unity3D generated file on crash reports
sysinfo.txt

# Builds
*.apk
*.aab
*.unitypackage
*.app

# Crashlytics generated file
crashlytics-build.properties

# OS generated
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
Icon?
ehthumbs.db
Thumbs.db

# Project specific
/[Aa]ssets/[Ss]treamingAssets/aa/*
/[Aa]ssets/[Ss]treamingAssets/aa.meta
</file>

<file path="ExampleScript.cs">
using Sirenix.OdinInspector;
using UnityEngine;
namespace PSS
{
    public class ExampleScript : MonoBehaviour
    {
        [Translated]
        public string myString;
        public void Start()
        {
            Application.targetFrameRate = 20;
            Test();
        }
        [Button]
        private void Test()
        {
            Debug.Log(Translations.Translate("Blue"));
            Debug.Log(Translations.Translate("Yellow"));
            Debug.Log(Translations.Translate(myString));
        }
    }
}
</file>

<file path="ExampleScript.cs.meta">
fileFormatVersion: 2
guid: bb621d7c032b67d479963b133a2b9228
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="ExampleScriptableObject.asset">
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: e7dfe8176c28c124b8674ab2a2dfe4d0, type: 3}
  m_Name: ExampleScriptableObject
  m_EditorClassIdentifier: 
  exampleString: aaa
</file>

<file path="ExampleScriptableObject.asset.meta">
fileFormatVersion: 2
guid: 34b4ad04c689d9a4e904429bd6f9e2ad
NativeFormatImporter:
  externalObjects: {}
  mainObjectFileID: 11400000
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="ExampleScriptableObject.cs">
using System.Collections;
using System.Collections.Generic;
using PSS;
using UnityEngine;
[CreateAssetMenu(fileName = "ExampleScriptableObject", menuName = "ExampleScriptableObject")]
public class ExampleScriptableObject : ScriptableObject
{
    [Translated]
    public string exampleString;
}
</file>

<file path="ExampleScriptableObject.cs.meta">
fileFormatVersion: 2
guid: e7dfe8176c28c124b8674ab2a2dfe4d0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="local-research.meta">
fileFormatVersion: 2
guid: 881bf6c2574d1b34f88cb3ed3a451152
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="local-research/localization-features.md">
Querying Perplexity AI using sonar-pro for: modern game localization features and best practices for Unity games 2024
Unity offers several modern localization features and best practices for game localization in 2024:

1. Built-in Localization Package:
- Supports string and asset localization
- Smart Strings feature for automatic placeholder and plural replacement
- Pseudo-localization for early testing
- Import/export to XLIFF, CSV and Google Sheets[4][7]

2. String Localization:
- Store strings externally in resource files (JSON, XML)
- Use unique string identifiers
- Implement careful string interpolation with numbered/named placeholders[2]

3. Asset Localization:
- Use AssetBundles to swap localized assets (textures, audio, etc.)[5]
- Design UI to accommodate text expansion (up to 35%)[2]

4. Cultural Adaptation:
- Adapt content, images, symbols to target cultures
- Ensure character names and dialogue are culturally appropriate[3]

5. Technical Best Practices:
- Use Unicode (UTF-8/UTF-16) for wide language support
- Handle plurals and grammatical cases
- Implement RTL language support
- Use locale-aware date/time/number formatting[2]

6. Workflow:
- Create a comprehensive localization kit with game context, character profiles, etc.
- Use a localization management tool (e.g. Gridly) for collaboration and automation[2]
- Implement separate translation memories for different projects[2]

7. QA:
- Test localized content display and UI layout
- Verify fonts, date/time formats for each locale[2]

8. Development:
- Use Unity's localization components to reduce manual coding[1]
- Leverage Unity's preloaded locales and language support[1]

Code example for string localization:

```csharp
using UnityEngine.Localization;
using UnityEngine.Localization.Settings;

public class LocalizationExample : MonoBehaviour
{
    public LocalizedString localizedText;

    void Start()
    {
        localizedText.StringChanged += UpdateText;
    }

    void UpdateText(string translatedText)
    {
        // Use the translated text
        Debug.Log(translatedText);
    }
}
```
</file>

<file path="local-research/localization-features.md.meta">
fileFormatVersion: 2
guid: e5e59fc9b745a3d48b5da9304557b2cc
TextScriptImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Test.prefab">
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &2262399843036308198
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 5731825953437789772}
  - component: {fileID: 4581567885450607025}
  m_Layer: 0
  m_Name: Test
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &5731825953437789772
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2262399843036308198}
  serializedVersion: 2
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 867.31885, y: 500.28, z: -1.2096864}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_ConstrainProportionsScale: 0
  m_Children: []
  m_Father: {fileID: 0}
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &4581567885450607025
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2262399843036308198}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: bb621d7c032b67d479963b133a2b9228, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  myString: bob
</file>

<file path="Test.prefab.meta">
fileFormatVersion: 2
guid: c877d7f22ed284e48b52417197bb0c15
PrefabImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations.meta">
fileFormatVersion: 2
guid: ae4d4d938a1beb94ba45bb9a7f6bd6ea
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/Editor.meta">
fileFormatVersion: 2
guid: 6ac640ed933394d41a6a537e093c63bc
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/Editor/TranslationsEditorWindow.cs">
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using UnityEngine.UIElements;
using System.Linq;
namespace PSS
{
    public class TranslationsEditorWindow : EditorWindow
    {
        private Vector2 scrollPosition;
        private TranslationData translationData;
        private string newLanguageName = "";
        private string searchFilter = "";
        private bool showMissingOnly = false;
        private bool showUnusedOnly = false;
        private Vector2 textScrollPosition;
        private string selectedKey = null;
        private bool autoTranslateEnabled = false;
        private string apiKey = "";
        // Extraction settings
        private bool extractFromScenes = true;
        private bool extractFromPrefabs = true;
        private bool extractFromScripts = true;
        private bool extractFromScriptableObjects = true;
        private bool includeInactive = false;
        private enum Tab
        {
            Settings,
            TextExtraction,
            AllText,
            Languages
        }
        private Tab currentTab = Tab.Languages;
        // Add coverage tracking
        private Dictionary<string, float> languageCoverage = new Dictionary<string, float>();
        private bool needsCoverageUpdate = true;
        private KeyUpdateMode updateMode = KeyUpdateMode.Replace;
        private bool isDirty = false;
        private float saveDelay = 1f;
        private double lastEditTime;
        [MenuItem("Window/Translations")]
        public static void ShowWindow()
        {
            GetWindow<TranslationsEditorWindow>("Translations Manager");
        }
        private void OnEnable()
        {
            translationData = Resources.Load<TranslationData>("TranslationData");
            LoadEditorPrefs();
            needsCoverageUpdate = true;
        }
        private void OnDisable()
        {
            SaveEditorPrefs();
        }
        private void LoadEditorPrefs()
        {
            autoTranslateEnabled = EditorPrefs.GetBool("TranslationManager_AutoTranslate", false);
            apiKey = EditorPrefs.GetString("TranslationManager_APIKey", "");
        }
        private void SaveEditorPrefs()
        {
            EditorPrefs.SetBool("TranslationManager_AutoTranslate", autoTranslateEnabled);
            EditorPrefs.SetString("TranslationManager_APIKey", apiKey);
        }
        private void UpdateCoverageData()
        {
            if (translationData == null) return;
            languageCoverage.Clear();
            // Skip English as it's always 100%
            languageCoverage["English"] = 100f;
            int totalKeys = translationData.allKeys.Count;
            if (totalKeys == 0) return;
            // Calculate coverage for each non-English language
            for (int i = 0; i < translationData.languageDataDictionary.Length; i++)
            {
                string language = translationData.supportedLanguages[i + 1]; // +1 to skip English
                var assetRef = translationData.languageDataDictionary[i];
                string assetPath = AssetDatabase.GUIDToAssetPath(assetRef.AssetGUID);
                LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                if (languageData != null)
                {
                    int nonEmptyTranslations = languageData.allText.Count(t => !string.IsNullOrWhiteSpace(t));
                    float coverage = totalKeys > 0 ? (nonEmptyTranslations * 100f) / totalKeys : 100f;
                    languageCoverage[language] = coverage;
                }
                else
                {
                    languageCoverage[language] = 0f;
                }
            }
            needsCoverageUpdate = false;
        }
        private void OnGUI()
        {
            EditorGUILayout.Space(10);
            if (translationData == null)
            {
                DrawNoTranslationDataUI();
                return;
            }
            DrawHeaderSection();
            EditorGUILayout.Space(5);
            // Draw tabs with icons using reliable built-in Unity icons
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            if (GUILayout.Toggle(currentTab == Tab.Settings, new GUIContent(" Settings", EditorGUIUtility.IconContent("d_Settings").image), EditorStyles.toolbarButton))
                currentTab = Tab.Settings;
            if (GUILayout.Toggle(currentTab == Tab.TextExtraction, new GUIContent(" Text Extraction", EditorGUIUtility.IconContent("d_Prefab Icon").image), EditorStyles.toolbarButton))
                currentTab = Tab.TextExtraction;
            if (GUILayout.Toggle(currentTab == Tab.AllText, new GUIContent(" All Text", EditorGUIUtility.IconContent("d_TextAsset Icon").image), EditorStyles.toolbarButton))
                currentTab = Tab.AllText;
            if (GUILayout.Toggle(currentTab == Tab.Languages, new GUIContent(" Languages", EditorGUIUtility.IconContent("d_BuildSettings.Standalone").image), EditorStyles.toolbarButton))
                currentTab = Tab.Languages;
            EditorGUILayout.EndHorizontal();
            // Global search bar
            if (currentTab != Tab.Settings)
            {
                EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
                searchFilter = EditorGUILayout.TextField(searchFilter, EditorStyles.toolbarSearchField);
                if (GUILayout.Button("Clear", EditorStyles.toolbarButton, GUILayout.Width(50)))
                    searchFilter = "";
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.Space(5);
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);
            switch (currentTab)
            {
                case Tab.Languages:
                    DrawLanguagesTab();
                    break;
                case Tab.AllText:
                    DrawAllTextTab();
                    break;
                case Tab.TextExtraction:
                    DrawTextExtractionTab();
                    break;
                case Tab.Settings:
                    DrawSettingsTab();
                    break;
            }
            EditorGUILayout.EndScrollView();
            // Status bar
            EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);
            EditorGUILayout.LabelField($"Total Keys: {translationData.allKeys.Count}", EditorStyles.miniLabel);
            EditorGUILayout.LabelField($"Languages: {translationData.supportedLanguages.Count}", EditorStyles.miniLabel);
            EditorGUILayout.EndHorizontal();
        }
        private void DrawNoTranslationDataUI()
        {
            EditorGUILayout.HelpBox("No TranslationData asset found in Resources folder.", MessageType.Warning);
            if (GUILayout.Button("Create TranslationData Asset"))
            {
                CreateTranslationDataAsset();
            }
        }
        private void DrawHeaderSection()
        {
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Translation Manager", EditorStyles.boldLabel);
            if (GUILayout.Button("Select TranslationData Asset", GUILayout.Width(180)))
            {
                Selection.activeObject = translationData;
            }
            EditorGUILayout.EndHorizontal();
        }
        private void DrawLanguagesTab()
        {
            if (needsCoverageUpdate)
            {
                UpdateCoverageData();
            }
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            // Language statistics
            EditorGUILayout.LabelField("Language Coverage", EditorStyles.boldLabel);
            EditorGUILayout.Space(5);
            foreach (var language in translationData.supportedLanguages)
            {
                float coverage = languageCoverage.TryGetValue(language, out float value) ? value : 0f;
                EditorGUILayout.BeginHorizontal();
                EditorGUILayout.LabelField(language, GUILayout.Width(150));
                EditorGUILayout.LabelField($"{coverage:F1}%", GUILayout.Width(50));
                EditorGUILayout.Space(5);
                DrawProgressBar(coverage / 100f);
                if (language != "English")
                {
                    if (GUILayout.Button("Export", GUILayout.Width(60)))
                    {
                        // Export language data
                    }
                    if (GUILayout.Button("Import", GUILayout.Width(60)))
                    {
                        // Import language data
                    }
                    if (GUILayout.Button("Remove", GUILayout.Width(60)))
                    {
                        if (EditorUtility.DisplayDialog("Remove Language", 
                            $"Are you sure you want to remove {language}?", "Remove", "Cancel"))
                        {
                            RemoveLanguage(language);
                        }
                    }
                }
                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.Space(10);
            // Add new language section
            EditorGUILayout.BeginHorizontal();
            newLanguageName = EditorGUILayout.TextField("New Language:", newLanguageName);
            GUI.enabled = !string.IsNullOrWhiteSpace(newLanguageName) && 
                         !translationData.supportedLanguages.Contains(newLanguageName);
            if (GUILayout.Button("Add", GUILayout.Width(60)))
            {
                AddNewLanguage(newLanguageName);
                newLanguageName = "";
                GUI.FocusControl(null);
            }
            GUI.enabled = true;
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space(10);
            if (GUILayout.Button("Setup Language Data Files"))
            {
                translationData.SetupLanguageDataAssets();
            }
            EditorGUILayout.Space(5);
            if (GUILayout.Button("Batch Auto-Translate Missing Texts"))
            {
                // Auto-translate implementation
            }
            if (GUILayout.Button("Refresh Coverage Data"))
            {
                needsCoverageUpdate = true;
                Repaint();
            }
            EditorGUILayout.EndVertical();
        }
        private void DrawAllTextTab()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            // Filters
            EditorGUILayout.BeginHorizontal();
            showMissingOnly = EditorGUILayout.ToggleLeft("Show Missing Translations Only", showMissingOnly, GUILayout.Width(200));
            showUnusedOnly = EditorGUILayout.ToggleLeft("Show Unused Keys Only", showUnusedOnly, GUILayout.Width(200));
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space(10);
            // Split view
            EditorGUILayout.BeginHorizontal();
            // Left side - keys list
            EditorGUILayout.BeginVertical(EditorStyles.helpBox, GUILayout.Width(300));
            DrawKeysList();
            EditorGUILayout.EndVertical();
            // Right side - translations
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            if (selectedKey != null)
            {
                DrawTranslationsForKey();
            }
            else
            {
                EditorGUILayout.LabelField("Select a key to edit translations", EditorStyles.centeredGreyMiniLabel);
            }
            EditorGUILayout.EndVertical();
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
        }
        private void DrawKeysList()
        {
            EditorGUILayout.LabelField("Translation Keys", EditorStyles.boldLabel);
            textScrollPosition = EditorGUILayout.BeginScrollView(textScrollPosition);
            var filteredKeys = translationData.allKeys
                .Where(k => string.IsNullOrEmpty(searchFilter) || k.ToLower().Contains(searchFilter.ToLower()));
            foreach (var key in filteredKeys)
            {
                bool isSelected = key == selectedKey;
                bool newSelected = EditorGUILayout.ToggleLeft(key, isSelected);
                if (newSelected != isSelected)
                {
                    selectedKey = newSelected ? key : null;
                }
            }
            EditorGUILayout.EndScrollView();
        }
        private void DrawTranslationsForKey()
        {
            if (selectedKey == null) return;
            EditorGUILayout.LabelField($"Translations for: {selectedKey}", EditorStyles.boldLabel);
            EditorGUILayout.Space(5);
            // Get the index of the selected key
            int keyIndex = translationData.allKeys.IndexOf(selectedKey);
            if (keyIndex == -1)
            {
                EditorGUILayout.HelpBox("Selected key not found in translation data.", MessageType.Error);
                return;
            }
            // Show English (original) text first
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("English", GUILayout.Width(150));
            GUI.enabled = false;
            EditorGUILayout.TextField(selectedKey);
            GUI.enabled = true;
            EditorGUILayout.EndHorizontal();
            // Show translations for other languages
            for (int i = 0; i < translationData.languageDataDictionary.Length; i++)
            {
                string language = translationData.supportedLanguages[i + 1]; // +1 to skip English
                var assetRef = translationData.languageDataDictionary[i];
                string assetPath = AssetDatabase.GUIDToAssetPath(assetRef.AssetGUID);
                LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                if (languageData != null && keyIndex < languageData.allText.Count)
                {
                    EditorGUILayout.BeginHorizontal();
                    EditorGUILayout.LabelField(language, GUILayout.Width(150));
                    string currentTranslation = languageData.allText[keyIndex];
                    EditorGUI.BeginChangeCheck();
                    string newTranslation = EditorGUILayout.TextField(currentTranslation);
                    if (EditorGUI.EndChangeCheck())
                    {
                        languageData.allText[keyIndex] = newTranslation;
                        EditorUtility.SetDirty(languageData);
                        isDirty = true;
                        lastEditTime = EditorApplication.timeSinceStartup;
                    }
                    if (GUILayout.Button("Auto", GUILayout.Width(60)))
                    {
                        // Auto-translate implementation
                    }
                    EditorGUILayout.EndHorizontal();
                }
                else
                {
                    EditorGUILayout.BeginHorizontal();
                    EditorGUILayout.LabelField(language, GUILayout.Width(150));
                    EditorGUILayout.HelpBox($"No translation data available for {language}", MessageType.Warning);
                    EditorGUILayout.EndHorizontal();
                }
            }
            // Handle delayed saving
            if (isDirty && EditorApplication.timeSinceStartup > lastEditTime + saveDelay)
            {
                AssetDatabase.SaveAssets();
                isDirty = false;
            }
            EditorGUILayout.Space(10);
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Copy Key to Clipboard"))
            {
                EditorGUIUtility.systemCopyBuffer = selectedKey;
            }
            if (GUILayout.Button("Remove Key"))
            {
                if (EditorUtility.DisplayDialog("Remove Key", 
                    "Are you sure you want to remove this key and all its translations?", 
                    "Remove", "Cancel"))
                {
                    RemoveTranslationKey(keyIndex);
                }
            }
            EditorGUILayout.EndHorizontal();
        }
        private void RemoveTranslationKey(int keyIndex)
        {
            Undo.RecordObject(translationData, "Remove Translation Key");
            // Remove from all language data files
            for (int i = 0; i < translationData.languageDataDictionary.Length; i++)
            {
                var assetRef = translationData.languageDataDictionary[i];
                string assetPath = AssetDatabase.GUIDToAssetPath(assetRef.AssetGUID);
                LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                if (languageData != null && keyIndex < languageData.allText.Count)
                {
                    Undo.RecordObject(languageData, "Remove Translation");
                    languageData.allText.RemoveAt(keyIndex);
                    EditorUtility.SetDirty(languageData);
                }
            }
            // Remove from translation data
            translationData.allKeys.RemoveAt(keyIndex);
            EditorUtility.SetDirty(translationData);
            // Clear selection
            selectedKey = null;
            needsCoverageUpdate = true;
            AssetDatabase.SaveAssets();
        }
        private void DrawTextExtractionTab()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            // Extraction Sources
            EditorGUILayout.LabelField("Extraction Sources", EditorStyles.boldLabel);
            EditorGUILayout.Space(5);
            extractFromScenes = EditorGUILayout.ToggleLeft(
                new GUIContent("Extract from Scenes", "Extract text from all scenes in build settings"), 
                extractFromScenes);
            extractFromPrefabs = EditorGUILayout.ToggleLeft(
                new GUIContent("Extract from Prefabs", "Extract text from all prefabs in the project"), 
                extractFromPrefabs);
            extractFromScripts = EditorGUILayout.ToggleLeft(
                new GUIContent("Extract from Scripts", "Find Translate() function calls in scripts"), 
                extractFromScripts);
            extractFromScriptableObjects = EditorGUILayout.ToggleLeft(
                new GUIContent("Extract from ScriptableObjects", "Extract text from all ScriptableObjects"), 
                extractFromScriptableObjects);
            includeInactive = EditorGUILayout.ToggleLeft(
                new GUIContent("Include Inactive GameObjects", "Extract text from disabled objects"), 
                includeInactive);
            EditorGUILayout.Space(10);
            // Extraction Mode
            EditorGUILayout.LabelField("Extraction Mode", EditorStyles.boldLabel);
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            EditorGUILayout.LabelField("Direct Update", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox(
                "Updates translation keys directly in the TranslationData asset. " +
                "Existing translations will be preserved.", 
                MessageType.Info);
            if (GUILayout.Button("Extract and Update Keys"))
            {
                if (EditorUtility.DisplayDialog("Extract Text", 
                    $"This will {(updateMode == KeyUpdateMode.Replace ? "replace" : "merge")} translation keys. Existing translations will be preserved. Continue?", 
                    "Extract", "Cancel"))
                {
                    var extractedText = TextExtractor.ExtractAllText(
                        extractFromScenes,
                        extractFromPrefabs,
                        extractFromScripts,
                        extractFromScriptableObjects,
                        includeInactive
                    );
                    TextExtractor.UpdateTranslationData(translationData, extractedText, updateMode);
                    needsCoverageUpdate = true;
                }
            }
            EditorGUILayout.Space(10);
            EditorGUILayout.LabelField("CSV Export", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox(
                "Exports found text to a CSV file. You can modify the CSV and import it back later.", 
                MessageType.Info);
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Extract to New CSV"))
            {
                ExtractToNewCSV();
            }
            if (GUILayout.Button("Update Existing CSV"))
            {
                ExtractToExistingCSV();
            }
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.EndVertical();
            EditorGUILayout.Space(10);
            // CSV Management
            EditorGUILayout.LabelField("CSV Management", EditorStyles.boldLabel);
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Import CSV"))
            {
                translationData.ImportCSV();
            }
            if (GUILayout.Button("Export Current Keys to CSV"))
            {
                ExportCurrentKeysToCSV();
            }
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space(10);
            if (GUILayout.Button("Generate Translation Report"))
            {
                GenerateReport();
            }
            EditorGUILayout.EndVertical();
            EditorGUILayout.Space(10);
            // Update Mode
            EditorGUILayout.LabelField("Update Mode", EditorStyles.boldLabel);
            updateMode = (KeyUpdateMode)EditorGUILayout.EnumPopup("Key Update Mode", updateMode);
            switch (updateMode)
            {
                case KeyUpdateMode.Replace:
                    EditorGUILayout.HelpBox(
                        "Replace mode will clear existing keys and add new ones, preserving translations for any keys that still exist.", 
                        MessageType.Info);
                    break;
                case KeyUpdateMode.Merge:
                    EditorGUILayout.HelpBox(
                        "Merge mode will keep existing keys and add new ones, preserving all existing translations.", 
                        MessageType.Info);
                    break;
            }
        }
        private void ExtractToNewCSV()
        {
            string path = EditorUtility.SaveFilePanel(
                "Save CSV File",
                "",
                "translations.csv",
                "csv");
            if (!string.IsNullOrEmpty(path))
            {
                TextExtractor.ExtractToCSV(
                    path,
                    translationData,
                    extractFromScenes,
                    extractFromPrefabs,
                    extractFromScripts,
                    extractFromScriptableObjects,
                    includeInactive
                );
            }
        }
        private void ExtractToExistingCSV()
        {
            string path = EditorUtility.OpenFilePanel("Select Existing CSV", "", "csv");
            if (!string.IsNullOrEmpty(path))
            {
                TextExtractor.UpdateExistingCSV(
                    path,
                    translationData,
                    extractFromScenes,
                    extractFromPrefabs,
                    extractFromScripts,
                    extractFromScriptableObjects,
                    includeInactive
                );
            }
        }
        private void ExportCurrentKeysToCSV()
        {
            string path = EditorUtility.SaveFilePanel(
                "Export Current Keys",
                "",
                "current_translations.csv",
                "csv");
            if (!string.IsNullOrEmpty(path))
            {
                TextExtractor.ExportCurrentKeys(path, translationData);
            }
        }
        private void GenerateReport()
        {
            string path = EditorUtility.SaveFilePanel(
                "Save Translation Report",
                "",
                "translation_report.txt",
                "txt");
            if (!string.IsNullOrEmpty(path))
            {
                TextExtractor.GenerateReport(
                    path,
                    translationData,
                    extractFromScenes,
                    extractFromPrefabs,
                    extractFromScripts,
                    extractFromScriptableObjects,
                    includeInactive
                );
            }
        }
        private void DrawSettingsTab()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            EditorGUILayout.LabelField("Translation Settings", EditorStyles.boldLabel);
            EditorGUILayout.Space(5);
            // Auto-translation settings
            EditorGUILayout.LabelField("Auto-Translation", EditorStyles.boldLabel);
            autoTranslateEnabled = EditorGUILayout.ToggleLeft("Enable Auto-Translation", autoTranslateEnabled);
            if (autoTranslateEnabled)
            {
                EditorGUI.indentLevel++;
                apiKey = EditorGUILayout.TextField("API Key:", apiKey);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.Space(10);
            // Font settings
            EditorGUILayout.LabelField("Font Management", EditorStyles.boldLabel);
            if (GUILayout.Button("Manage Fonts"))
            {
                // Open font management window
            }
            EditorGUILayout.Space(10);
            // Backup settings
            EditorGUILayout.LabelField("Backup Settings", EditorStyles.boldLabel);
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Create Backup"))
            {
                // Backup implementation
            }
            if (GUILayout.Button("Restore from Backup"))
            {
                // Restore implementation
            }
            EditorGUILayout.EndHorizontal();
            EditorGUILayout.Space(10);
            // Development tools
            EditorGUILayout.LabelField("Development Tools", EditorStyles.boldLabel);
            if (GUILayout.Button("Validate All Translations"))
            {
                // Validation implementation
            }
            if (GUILayout.Button("Clean Unused Keys"))
            {
                // Cleanup implementation
            }
            EditorGUILayout.EndVertical();
        }
        private void DrawProgressBar(float value)
        {
            Rect rect = GUILayoutUtility.GetRect(50, 18);
            EditorGUI.ProgressBar(rect, value, "");
        }
        private void CreateTranslationDataAsset()
        {
            translationData = ScriptableObject.CreateInstance<TranslationData>();
            if (!AssetDatabase.IsValidFolder("Assets/Resources"))
            {
                AssetDatabase.CreateFolder("Assets", "Resources");
            }
            AssetDatabase.CreateAsset(translationData, "Assets/Resources/TranslationData.asset");
            AssetDatabase.SaveAssets();
            Selection.activeObject = translationData;
            Debug.Log("Created new TranslationData asset in Resources folder");
        }
        private void AddNewLanguage(string language)
        {
            Undo.RecordObject(translationData, "Add Language");
            translationData.supportedLanguages.Add(language);
            EditorUtility.SetDirty(translationData);
            AssetDatabase.SaveAssets();
        }
        private void RemoveLanguage(string language)
        {
            Undo.RecordObject(translationData, "Remove Language");
            int index = translationData.supportedLanguages.IndexOf(language);
            translationData.supportedLanguages.RemoveAt(index);
            // Remove the language data file if it exists
            string sanitizedName = language.Replace(" ", "_").Replace("(", "_").Replace(")", "_");
            string assetPath = $"Assets/Resources/LanguageData_{sanitizedName}.asset";
            if (AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath) != null)
            {
                AssetDatabase.DeleteAsset(assetPath);
            }
            EditorUtility.SetDirty(translationData);
            AssetDatabase.SaveAssets();
            needsCoverageUpdate = true;
        }
        private void OnInspectorUpdate()
        {
            // Trigger repaint to check for delayed save
            if (isDirty)
            {
                Repaint();
            }
        }
    }
}
</file>

<file path="Translations/Editor/TranslationsEditorWindow.cs.meta">
fileFormatVersion: 2
guid: c320ba2b9b18f6b419648643b7f290eb
</file>

<file path="Translations/LanguageData.cs">
using System.Collections.Generic;
using UnityEngine;
namespace PSS
{
    [CreateAssetMenu(fileName = "LanguageData", menuName = "Localization/LanguageData")]
    public class LanguageData : ScriptableObject
    {
        public List<string> allText = new List<string>();
    }
}
</file>

<file path="Translations/LanguageData.cs.meta">
fileFormatVersion: 2
guid: dde7df3f20834b845875145f13c31cfe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/PSS.Translations.asmdef">
{
    "name": "PSS.Translations",
    "rootNamespace": "PSS",
    "references": [
        "GUID:6055be8ebefd69e48b49212b09b47b2f",
        "GUID:9e24947de15b9834991c9d8411ea37cf",
        "GUID:84651a3751eca9349aac36a66bba901b",
        "GUID:69448af7b92c7f342b298e06a37122aa"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}
</file>

<file path="Translations/PSS.Translations.asmdef.meta">
fileFormatVersion: 2
guid: 2e6e82fe5578b0244b2fef4b9a3bbb59
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/TextExtractor.cs">
#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;
using UnityEngine.SceneManagement;
using System.IO;
using System.Collections.Generic;
using TMPro;
using UnityEditor.SceneManagement;
using System.Text.RegularExpressions;
using System.Reflection;
using UnityEngine.UI;
using System.Linq;
using System;
namespace PSS
{
    public enum KeyUpdateMode
    {
        Replace,  // Clear existing and add new keys
        Merge     // Keep existing and add new keys
    }
    public class TextExtractor
    {
        public static HashSet<string> ExtractAllText(
            bool fromScenes,
            bool fromPrefabs,
            bool fromScripts,
            bool fromScriptableObjects,
            bool includeInactive)
        {
            HashSet<string> extractedText = new HashSet<string>();
            if (fromScenes)
                ExtractTextFromScenes(extractedText, includeInactive);
            if (fromPrefabs)
                ExtractTaggedStringFieldsFromPrefabs(extractedText, includeInactive);
            if (fromScripts)
                ExtractTranslateFunctionTexts(extractedText);
            if (fromScriptableObjects)
                ExtractScriptableObjectFields(extractedText);
            return extractedText;
        }
        public static void ExtractToCSV(
            string filePath,
            TranslationData translationData,
            bool fromScenes,
            bool fromPrefabs,
            bool fromScripts,
            bool fromScriptableObjects,
            bool includeInactive)
        {
            var extractedText = ExtractAllText(fromScenes, fromPrefabs, fromScripts, fromScriptableObjects, includeInactive);
            WriteNewCSVWithExistingTranslations(filePath, extractedText, translationData);
        }
        public static void UpdateExistingCSV(
            string filePath,
            TranslationData translationData,
            bool fromScenes,
            bool fromPrefabs,
            bool fromScripts,
            bool fromScriptableObjects,
            bool includeInactive)
        {
            var extractedText = ExtractAllText(fromScenes, fromPrefabs, fromScripts, fromScriptableObjects, includeInactive);
            List<string[]> existingRows = new List<string[]>();
            Dictionary<string, string[]> existingTranslations = new Dictionary<string, string[]>();
            // Read existing CSV and store its translations
            if (File.Exists(filePath))
            {
                using (var reader = new StreamReader(filePath))
                {
                    string[] headers = reader.ReadLine()?.Split(',');
                    if (headers != null)
                    {
                        existingRows.Add(headers);
                        while (!reader.EndOfStream)
                        {
                            string[] row = reader.ReadLine()?.Split(',');
                            if (row != null && row.Length > 0)
                            {
                                existingTranslations[row[0]] = row;
                            }
                        }
                    }
                }
            }
            else
            {
                // If file doesn't exist, create headers
                existingRows.Add(translationData.supportedLanguages.ToArray());
            }
            // Create a dictionary of current translations from TranslationData
            Dictionary<string, Dictionary<string, string>> currentTranslations = new Dictionary<string, Dictionary<string, string>>();
            for (int i = 0; i < translationData.allKeys.Count; i++)
            {
                string key = translationData.allKeys[i];
                currentTranslations[key] = new Dictionary<string, string>();
                for (int j = 0; j < translationData.languageDataDictionary.Length; j++)
                {
                    string language = translationData.supportedLanguages[j + 1];
                    string assetPath = AssetDatabase.GUIDToAssetPath(translationData.languageDataDictionary[j].AssetGUID);
                    LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                    if (languageData != null && i < languageData.allText.Count)
                    {
                        currentTranslations[key][language] = languageData.allText[i];
                    }
                }
            }
            // Clear existing rows except header
            existingRows.RemoveRange(1, existingRows.Count - 1);
            // Add rows for each extracted text
            foreach (string text in extractedText)
            {
                string[] row = new string[existingRows[0].Length];
                row[0] = text;
                // First try to get translations from existing CSV
                if (existingTranslations.TryGetValue(text, out string[] existingRow))
                {
                    for (int i = 1; i < Math.Min(existingRow.Length, row.Length); i++)
                    {
                        row[i] = existingRow[i];
                    }
                }
                // Then fill in any missing translations from current TranslationData
                if (currentTranslations.TryGetValue(text, out var translations))
                {
                    for (int i = 1; i < translationData.supportedLanguages.Count; i++)
                    {
                        string language = translationData.supportedLanguages[i];
                        if (string.IsNullOrEmpty(row[i]) && translations.TryGetValue(language, out string translation))
                        {
                            row[i] = translation;
                        }
                    }
                }
                existingRows.Add(row);
            }
            // Write updated CSV
            WriteToCSV(filePath, existingRows);
        }
        public static void ExportCurrentKeys(string filePath, TranslationData translationData)
        {
            List<string[]> rows = new List<string[]>();
            // Add header
            rows.Add(translationData.supportedLanguages.ToArray());
            // Add translations
            for (int i = 0; i < translationData.allKeys.Count; i++)
            {
                string[] row = new string[translationData.supportedLanguages.Count];
                row[0] = translationData.allKeys[i]; // English key
                // Add translations for other languages
                for (int j = 0; j < translationData.languageDataDictionary.Length; j++)
                {
                    string assetPath = AssetDatabase.GUIDToAssetPath(translationData.languageDataDictionary[j].AssetGUID);
                    LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                    if (languageData != null && i < languageData.allText.Count)
                    {
                        row[j + 1] = languageData.allText[i];
                    }
                }
                rows.Add(row);
            }
            WriteToCSV(filePath, rows);
        }
        public static void GenerateReport(
            string filePath,
            TranslationData translationData,
            bool fromScenes,
            bool fromPrefabs,
            bool fromScripts,
            bool fromScriptableObjects,
            bool includeInactive)
        {
            var extractedText = ExtractAllText(fromScenes, fromPrefabs, fromScripts, fromScriptableObjects, includeInactive);
            var unusedKeys = translationData.allKeys.Where(k => !extractedText.Contains(k)).ToList();
            var missingKeys = extractedText.Where(k => !translationData.allKeys.Contains(k)).ToList();
            using (StreamWriter writer = new StreamWriter(filePath))
            {
                writer.WriteLine("Translation System Report");
                writer.WriteLine("========================");
                writer.WriteLine($"Generated: {System.DateTime.Now}\n");
                writer.WriteLine("Statistics:");
                writer.WriteLine($"Total Keys: {translationData.allKeys.Count}");
                writer.WriteLine($"Total Languages: {translationData.supportedLanguages.Count}");
                writer.WriteLine($"Unused Keys: {unusedKeys.Count}");
                writer.WriteLine($"Missing Keys: {missingKeys.Count}\n");
                writer.WriteLine("Language Coverage:");
                foreach (var language in translationData.supportedLanguages.Skip(1))
                {
                    int index = translationData.supportedLanguages.IndexOf(language) - 1;
                    string assetPath = AssetDatabase.GUIDToAssetPath(translationData.languageDataDictionary[index].AssetGUID);
                    LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                    if (languageData != null)
                    {
                        int nonEmptyCount = languageData.allText.Count(t => !string.IsNullOrWhiteSpace(t));
                        float coverage = translationData.allKeys.Count > 0 
                            ? (nonEmptyCount * 100f) / translationData.allKeys.Count 
                            : 100f;
                        writer.WriteLine($"{language}: {coverage:F1}% ({nonEmptyCount}/{translationData.allKeys.Count})");
                    }
                }
                if (unusedKeys.Count > 0)
                {
                    writer.WriteLine("\nUnused Keys:");
                    foreach (var key in unusedKeys)
                    {
                        writer.WriteLine($"- {key}");
                    }
                }
                if (missingKeys.Count > 0)
                {
                    writer.WriteLine("\nMissing Keys:");
                    foreach (var key in missingKeys)
                    {
                        writer.WriteLine($"- {key}");
                    }
                }
            }
        }
        private static void WriteNewCSVWithExistingTranslations(string filePath, HashSet<string> extractedText, TranslationData translationData)
        {
            List<string[]> rows = new List<string[]>();
            // Add header with all supported languages
            rows.Add(translationData.supportedLanguages.ToArray());
            // Create a dictionary to store existing translations
            Dictionary<string, string[]> translations = new Dictionary<string, string[]>();
            // Load existing translations for all keys
            for (int keyIndex = 0; keyIndex < translationData.allKeys.Count; keyIndex++)
            {
                string key = translationData.allKeys[keyIndex];
                string[] translationRow = new string[translationData.supportedLanguages.Count];
                translationRow[0] = key; // English (key)
                // Get translations for each language
                for (int langIndex = 0; langIndex < translationData.languageDataDictionary.Length; langIndex++)
                {
                    string assetPath = AssetDatabase.GUIDToAssetPath(translationData.languageDataDictionary[langIndex].AssetGUID);
                    LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                    if (languageData != null && keyIndex < languageData.allText.Count)
                    {
                        // langIndex + 1 because first column is English
                        translationRow[langIndex + 1] = languageData.allText[keyIndex];
                    }
                }
                translations[key] = translationRow;
            }
            // Add rows for each extracted text
            foreach (string text in extractedText)
            {
                if (translations.TryGetValue(text, out string[] existingTranslations))
                {
                    // Use existing translations if available
                    rows.Add(existingTranslations);
                }
                else
                {
                    // Create new row with just the English text
                    string[] newRow = new string[translationData.supportedLanguages.Count];
                    newRow[0] = text;
                    rows.Add(newRow);
                }
            }
            WriteToCSV(filePath, rows);
        }
        public static void ExtractTextFromScenes(HashSet<string> extractedText, bool includeInactive)
        {
            for (int i = 0; i < EditorBuildSettings.scenes.Length; i++)
            {
                string scenePath = EditorBuildSettings.scenes[i].path;
                Scene scene = SceneManager.GetSceneByPath(scenePath);
                if (!scene.isLoaded)
                {
                    scene = EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Single);
                }
                // Extract TextMeshPro texts
                TextMeshProUGUI[] textMeshProObjects = GameObject.FindObjectsOfType<TextMeshProUGUI>(includeInactive);
                foreach (TextMeshProUGUI textObject in textMeshProObjects)
                {
                    if (!string.IsNullOrWhiteSpace(textObject.text))
                    {
                        extractedText.Add(textObject.text);
                    }
                }
                // Extract UI Text texts
                Text[] uiTextObjects = GameObject.FindObjectsOfType<Text>(includeInactive);
                foreach (Text uiText in uiTextObjects)
                {
                    if (!string.IsNullOrWhiteSpace(uiText.text))
                    {
                        extractedText.Add(uiText.text);
                    }
                }
                // Extract fields marked with TranslatedAttribute
                foreach (GameObject rootObj in scene.GetRootGameObjects())
                {
                    ExtractFromGameObject(rootObj, extractedText, includeInactive);
                }
            }
        }
        private static void ExtractFromGameObject(GameObject obj, HashSet<string> extractedText, bool includeInactive)
        {
            if (!includeInactive && !obj.activeInHierarchy) return;
            Component[] components = obj.GetComponents<Component>();
            foreach (Component component in components)
            {
                if (component == null) continue;
                ExtractFieldsRecursive(component, extractedText);
            }
            foreach (Transform child in obj.transform)
            {
                ExtractFromGameObject(child.gameObject, extractedText, includeInactive);
            }
        }
        public static void ExtractTranslateFunctionTexts(HashSet<string> extractedText)
        {
            string[] scriptPaths = Directory.GetFiles("Assets", "*.cs", SearchOption.AllDirectories);
            Regex translateRegex = new Regex(@"Translations\.Translate\(\s*""([^""]+)""\s*\)");
            foreach (string scriptPath in scriptPaths)
            {
                string scriptContent = File.ReadAllText(scriptPath);
                MatchCollection matches = translateRegex.Matches(scriptContent);
                foreach (Match match in matches)
                {
                    if (match.Groups.Count > 1)
                    {
                        string matchedText = match.Groups[1].Value;
                        extractedText.Add(matchedText);
                    }
                }
            }
        }
        public static void ExtractScriptableObjectFields(HashSet<string> extractedText)
        {
            string[] guids = AssetDatabase.FindAssets("t:ScriptableObject");
            foreach (string guid in guids)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);
                ScriptableObject scriptableObject = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);
                if (scriptableObject != null)
                {
                    ExtractFieldsRecursive(scriptableObject, extractedText);
                }
            }
        }
        public static void ExtractTaggedStringFieldsFromPrefabs(HashSet<string> extractedText, bool includeInactive)
        {
            string[] prefabGuids = AssetDatabase.FindAssets("t:Prefab");
            foreach (string guid in prefabGuids)
            {
                string path = AssetDatabase.GUIDToAssetPath(guid);
                GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);
                if (prefab != null)
                {
                    Component[] allComponents = prefab.GetComponentsInChildren<Component>(true);
                    foreach (Component component in allComponents)
                    {
                        if (component == null)
                        {
                            Debug.LogWarning("Null component found in prefab: " + path);
                            continue;
                        }
                        ExtractFieldsRecursive(component, extractedText);
                    }
                }
            }
        }
        private static void ExtractFieldsRecursive(object obj, HashSet<string> extractedText)
        {
            if (obj == null) return;
            FieldInfo[] fields = obj.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            foreach (FieldInfo field in fields)
            {
                if (field.IsDefined(typeof(TranslatedAttribute), false))
                {
                    if (field.FieldType == typeof(string))
                    {
                        string fieldValue = field.GetValue(obj) as string;
                        extractedText.Add(fieldValue);
                    }
                    else if (!field.FieldType.IsPrimitive && !field.FieldType.IsEnum && field.FieldType.IsClass)
                    {
                        object nestedObj = field.GetValue(obj);
                        ExtractFieldsRecursive(nestedObj, extractedText);
                    }
                }
            }
        }
        public static void WriteToCSV(string filePath, List<string[]> rowData)
        {
            using (StreamWriter outStream = new StreamWriter(filePath))
            {
                foreach (string[] row in rowData)
                {
                    string[] escapedFields = row.Select(field => 
                    {
                        if (string.IsNullOrEmpty(field))
                            return "";
                        bool needsQuotes = field.Contains(",") || field.Contains("\"") || field.Contains("\n");
                        if (needsQuotes)
                        {
                            return $"\"{field.Replace("\"", "\"\"")}\"";
                        }
                        return field;
                    }).ToArray();
                    outStream.WriteLine(string.Join(",", escapedFields));
                }
            }
        }
        public static void UpdateTranslationData(
            TranslationData translationData,
            HashSet<string> newKeys,
            KeyUpdateMode updateMode)
        {
            if (updateMode == KeyUpdateMode.Replace)
            {
                // Store existing translations before clearing
                Dictionary<string, Dictionary<string, string>> existingTranslations = new Dictionary<string, Dictionary<string, string>>();
                // Load existing translations
                for (int i = 0; i < translationData.allKeys.Count; i++)
                {
                    string key = translationData.allKeys[i];
                    existingTranslations[key] = new Dictionary<string, string>();
                    for (int j = 0; j < translationData.languageDataDictionary.Length; j++)
                    {
                        string language = translationData.supportedLanguages[j + 1];
                        string assetPath = AssetDatabase.GUIDToAssetPath(translationData.languageDataDictionary[j].AssetGUID);
                        LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                        if (languageData != null && i < languageData.allText.Count)
                        {
                            existingTranslations[key][language] = languageData.allText[i];
                        }
                    }
                }
                // Clear existing data
                translationData.allKeys.Clear();
                foreach (var assetRef in translationData.languageDataDictionary)
                {
                    string assetPath = AssetDatabase.GUIDToAssetPath(assetRef.AssetGUID);
                    LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                    if (languageData != null)
                    {
                        languageData.allText.Clear();
                    }
                }
                // Add new keys
                foreach (string key in newKeys)
                {
                    translationData.allKeys.Add(key);
                    // Add translations for each language
                    foreach (var assetRef in translationData.languageDataDictionary)
                    {
                        string assetPath = AssetDatabase.GUIDToAssetPath(assetRef.AssetGUID);
                        LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                        if (languageData != null)
                        {
                            string translation = "";
                            if (existingTranslations.TryGetValue(key, out var translations))
                            {
                                string language = translationData.supportedLanguages[translationData.languageDataDictionary.ToList().IndexOf(assetRef) + 1];
                                translation = translations.TryGetValue(language, out string existingTranslation) ? existingTranslation : "";
                            }
                            languageData.allText.Add(translation);
                            EditorUtility.SetDirty(languageData);
                        }
                    }
                }
            }
            else // Merge mode
            {
                foreach (string key in newKeys)
                {
                    if (!translationData.allKeys.Contains(key))
                    {
                        translationData.allKeys.Add(key);
                        // Add empty translation for each language
                        foreach (var assetRef in translationData.languageDataDictionary)
                        {
                            string assetPath = AssetDatabase.GUIDToAssetPath(assetRef.AssetGUID);
                            LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                            if (languageData != null)
                            {
                                languageData.allText.Add("");
                                EditorUtility.SetDirty(languageData);
                            }
                        }
                    }
                }
            }
            EditorUtility.SetDirty(translationData);
            AssetDatabase.SaveAssets();
        }
    }
}
#endif
</file>

<file path="Translations/TextExtractor.cs.meta">
fileFormatVersion: 2
guid: e20ac9d7322be724bbe87530ac989cbc
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/TranslatedAttribute.cs">
using System;
using UnityEngine;
namespace PSS
{
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class TranslatedAttribute : PropertyAttribute
    {
    }
}
</file>

<file path="Translations/TranslatedAttribute.cs.meta">
fileFormatVersion: 2
guid: 0e8055f159d3fbe4388aacdbb3ea006e
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/TranslationData.cs">
using System;
using System.Collections.Generic;
using UnityEngine;
using Sirenix.OdinInspector;
using System.IO;
using Sirenix.Serialization;
using TMPro;
using System.Linq;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.AddressableAssets;
using UnityEditor.AddressableAssets.Settings;
#endif
using UnityEngine.AddressableAssets;
namespace PSS
{
    [CreateAssetMenu(fileName = "TranslationData", menuName = "Localization/TranslationData")]
    public class TranslationData : SerializedScriptableObject
    {
        // Add list of supported languages
        public List<string> supportedLanguages = new List<string>
        {
            "English",
            "French", 
            "Italian", 
            "German", 
            "Danish", 
            "Dutch", 
            "Japanese",
            "Korean", 
            "Portuguese", 
            "Portuguese (Brazil)", 
            "Russian", 
            "Chinese (Simplified)",
            "Spanish", 
            "Swedish", 
            "Chinese (Traditional)", 
            "Ukrainian"
        };
        public AssetReference[] languageDataDictionary = new AssetReference[0];
        public List<string> allKeys = new List<string>();
        [OdinSerialize]
        public Dictionary<TMP_FontAsset, Dictionary<string, TMP_FontAsset>> fonts = 
            new Dictionary<TMP_FontAsset, Dictionary<string, TMP_FontAsset>>();
#if UNITY_EDITOR
        [Button("Setup Language Data Assets")]
        public void SetupLanguageDataAssets()
        {
            // Get or create Addressables settings
            var settings = AddressableAssetSettingsDefaultObject.GetSettings(true);
            // Create a group for language data if it doesn't exist
            AddressableAssetGroup languageGroup = settings.FindGroup("LanguageData");
            if (languageGroup == null)
            {
                languageGroup = settings.CreateGroup("LanguageData", false, false, true, null);
            }
            // Resize array to match number of non-English languages
            int nonEnglishCount = supportedLanguages.Count - 1; // Exclude English
            if (languageDataDictionary.Length != nonEnglishCount)
            {
                Array.Resize(ref languageDataDictionary, nonEnglishCount);
            }
            // Create language data assets for each supported language (except English)
            for (int i = 1; i < supportedLanguages.Count; i++) // Start from 1 to skip English
            {
                string language = supportedLanguages[i];
                string sanitizedName = SanitizeFileName(language);
                string assetPath = $"Assets/Resources/LanguageData_{sanitizedName}.asset";
                // Check if asset already exists
                LanguageData languageData = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                if (languageData == null)
                {
                    // Create new language data asset
                    languageData = CreateInstance<LanguageData>();
                    AssetDatabase.CreateAsset(languageData, assetPath);
                }
                // Make the asset addressable
                var guid = AssetDatabase.AssetPathToGUID(assetPath);
                var entry = settings.CreateOrMoveEntry(guid, languageGroup);
                entry.address = $"LanguageData_{sanitizedName}";
                // Update the asset reference in the dictionary
                languageDataDictionary[i - 1] = new AssetReference(guid);
            }
            AssetDatabase.SaveAssets();
            EditorUtility.SetDirty(this);
            AssetDatabase.Refresh();
            Debug.Log("Language data assets setup complete!");
        }
        private string SanitizeFileName(string fileName)
        {
            // Replace spaces with underscores and remove invalid characters
            fileName = fileName.Replace(' ', '_');
            string invalid = new string(Path.GetInvalidFileNameChars()) + new string(Path.GetInvalidPathChars()) + "()";
            foreach (char c in invalid)
            {
                fileName = fileName.Replace(c.ToString(), string.Empty);
            }
            return fileName;
        }
        [Button("Import CSV")]
        public void ImportCSV()
        {
            string csvPath = EditorUtility.OpenFilePanel("Select CSV File", "", "csv");
            if (!string.IsNullOrEmpty(csvPath))
            {
                ReadCSV(csvPath);
            }
        }
        [Button("Clear Data")]
        public void ClearData()
        {
            allKeys.Clear();
            foreach (var data in languageDataDictionary)
            {
                LanguageData asset = AssetDatabase.LoadAssetAtPath<LanguageData>(AssetDatabase.GUIDToAssetPath(data.AssetGUID));
                asset.allText.Clear();
                EditorUtility.SetDirty(asset);
            }
        }
        private void ReadCSV(string filePath)
        {
            List<string[]> rows = ParseCSV(filePath);
            if (rows.Count < 2)
            {
                Debug.LogError("CSV file is empty or not properly formatted.");
                return;
            }
            string[] headers = rows[0];
            // Find the English column index
            int englishIndex = Array.IndexOf(headers, "English");
            if (englishIndex == -1)
            {
                Debug.LogError("CSV must contain an 'English' column.");
                return;
            }
            // Create a mapping of language names to their column indices
            Dictionary<string, int> languageColumns = new Dictionary<string, int>();
            Dictionary<string, LanguageData> languageDataAssets = new Dictionary<string, LanguageData>();
            // Initialize language data assets
            for (int i = 0; i < languageDataDictionary.Length; i++)
            {
                string language = supportedLanguages[i + 1]; // +1 to skip English
                string assetPath = AssetDatabase.GUIDToAssetPath(languageDataDictionary[i].AssetGUID);
                LanguageData asset = AssetDatabase.LoadAssetAtPath<LanguageData>(assetPath);
                if (asset != null)
                {
                    languageDataAssets[language] = asset;
                    asset.allText.Clear(); // Clear existing translations
                }
                else
                {
                    Debug.LogError($"Could not load language data asset for {language}");
                    return;
                }
            }
            // Find column indices for each supported language
            for (int i = 0; i < headers.Length; i++)
            {
                if (supportedLanguages.Contains(headers[i]) && headers[i] != "English")
                {
                    languageColumns[headers[i]] = i;
                }
            }
            // Clear existing keys
            allKeys.Clear();
            // Process each row
            for (int rowIndex = 1; rowIndex < rows.Count; rowIndex++)
            {
                string[] fields = rows[rowIndex];
                if (fields.Length <= englishIndex)
                {
                    Debug.LogWarning($"Skipping row {rowIndex + 1}: insufficient columns");
                    continue;
                }
                string englishText = fields[englishIndex];
                if (string.IsNullOrWhiteSpace(englishText))
                {
                    continue;
                }
                // Add the English key
                allKeys.Add(englishText);
                // Add translations for each language
                foreach (var language in supportedLanguages.Skip(1)) // Skip English
                {
                    if (languageColumns.TryGetValue(language, out int columnIndex) && 
                        languageDataAssets.TryGetValue(language, out LanguageData asset))
                    {
                        string translation = columnIndex < fields.Length ? fields[columnIndex] : "";
                        asset.allText.Add(translation);
                    }
                    else
                    {
                        // If language column not found in CSV, add empty translation
                        if (languageDataAssets.TryGetValue(language, out LanguageData asset2))
                        {
                            asset2.allText.Add("");
                        }
                    }
                }
            }
            // Save all changes
            foreach (var asset in languageDataAssets.Values)
            {
                EditorUtility.SetDirty(asset);
            }
            EditorUtility.SetDirty(this);
            AssetDatabase.SaveAssets();
            Debug.Log("CSV import complete. Translations updated.");
        }
        private List<string[]> ParseCSV(string filePath)
        {
            List<string[]> rows = new List<string[]>();
            using (var reader = new StreamReader(filePath))
            {
                bool inQuotes = false;
                string line;
                string currentField = "";
                List<string> currentRow = new List<string>();
                while ((line = reader.ReadLine()) != null)
                {
                    for (int i = 0; i < line.Length; i++)
                    {
                        char c = line[i];
                        if (c == '\"')
                        {
                            inQuotes = !inQuotes;
                        }
                        else if (c == ',' && !inQuotes)
                        {
                            currentRow.Add(currentField);
                            currentField = "";
                        }
                        else
                        {
                            currentField += c;
                        }
                    }
                    if (inQuotes)
                    {
                        currentField += "\n";
                    }
                    else
                    {
                        currentRow.Add(currentField);
                        rows.Add(currentRow.ToArray());
                        currentRow.Clear();
                        currentField = "";
                    }
                }
                // Add last row if file doesn't end with a newline
                if (currentRow.Count > 0)
                {
                    currentRow.Add(currentField);
                    rows.Add(currentRow.ToArray());
                }
            }
            return rows;
        }
        [Button]
        public void AddFont(TMP_FontAsset font)
        {
            fonts ??= new Dictionary<TMP_FontAsset, Dictionary<string, TMP_FontAsset>>();
            if (!fonts.ContainsKey(font))
            {
                fonts[font] = new Dictionary<string, TMP_FontAsset>();
                foreach (var language in supportedLanguages)
                {
                    fonts[font][language] = null;
                }
            }
        }
#endif
    }
}
</file>

<file path="Translations/TranslationData.cs.meta">
fileFormatVersion: 2
guid: 8759e3a1e24536043a139b1e57576011
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/TranslationManager.cs">
using System.Collections.Generic;
using UnityEngine;
using TMPro;
using System;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace PSS
{
    public static class TranslationManager
    {
        private static TranslationData translationData;
        private static Dictionary<string, string> translations = new Dictionary<string, string>();
        private static string currentLanguage = "English";
        private static AssetReference currentLanguageAssetRef;
        public static event Action OnLanguageChanged;
        private static TranslationData TranslationData
        {
            get
            {
                if (translationData == null)
                {
                    translationData = Resources.Load<TranslationData>("TranslationData");
#if UNITY_EDITOR
                    if (translationData == null)
                    {
                        // Create the TranslationData asset if it doesn't exist
                        translationData = ScriptableObject.CreateInstance<TranslationData>();
                        // Ensure the Resources folder exists
                        if (!AssetDatabase.IsValidFolder("Assets/Resources"))
                        {
                            AssetDatabase.CreateFolder("Assets", "Resources");
                        }
                        AssetDatabase.CreateAsset(translationData, "Assets/Resources/TranslationData.asset");
                        AssetDatabase.SaveAssets();
                        Debug.Log("Created new TranslationData asset in Resources folder");
                    }
#endif
                }
                return translationData;
            }
        }
        static TranslationManager()
        {
            LoadLanguage();
            SetLanguage();
        }
        public static void ChangeLanguage(string language)
        {
            if (!TranslationData.supportedLanguages.Contains(language))
            {
                Debug.LogError($"Unsupported language: {language}");
                return;
            }
            if (currentLanguage != language)
            {
                UnloadCurrentLanguage();
                currentLanguage = language;
                PlayerPrefs.SetString("Language", currentLanguage);
                PlayerPrefs.Save();
                SetLanguage();
            }
        }
        private static void LoadLanguage()
        {
            currentLanguage = PlayerPrefs.GetString("Language", "English");
        }
        private static void SetLanguage()
        {
            LoadLanguage(currentLanguage, () =>
            {
                OnLanguageChanged?.Invoke();
            });
        }
        public static string Translate(string originalText)
        {
            if (currentLanguage == "English") return originalText;
            return translations.TryGetValue(originalText, out string translation) ? translation : originalText;
        }
        public static TMP_FontAsset GetFontForText(TMP_FontAsset defaultFont)
        {
            if (TranslationData.fonts.TryGetValue(defaultFont, out Dictionary<string, TMP_FontAsset> fontDictionary)
                && fontDictionary.TryGetValue(currentLanguage, out TMP_FontAsset font))
            {
                return font;
            }
            return defaultFont;
        }
        private static void UnloadCurrentLanguage()
        {
            if (currentLanguageAssetRef != null)
            {
                currentLanguageAssetRef.ReleaseAsset();
                currentLanguageAssetRef = null;
                translations.Clear();
            }
        }
        private static void LoadLanguage(string language, Action onComplete)
        {
            if (language == "English")
            {
                onComplete?.Invoke();
                return;
            }
            int languageIndex = TranslationData.supportedLanguages.IndexOf(language) - 1;
            if (languageIndex < 0)
            {
                Debug.LogError($"Invalid language index for {language}");
                return;
            }
            var languageData = TranslationData.languageDataDictionary[languageIndex];
            LoadLanguageData(languageData, data =>
            {
                if (data != null)
                {
                    onComplete?.Invoke();
                }
            });
        }
        private static void LoadLanguageData(AssetReference assetRef, Action<LanguageData> onComplete)
        {
            translations.Clear();
            assetRef.LoadAssetAsync<LanguageData>().Completed += operation =>
            {
                if (operation.Status == AsyncOperationStatus.Succeeded)
                {
                    for (var i = 0; i < operation.Result.allText.Count; i++)
                    {
                        var text = operation.Result.allText[i];
                        translations[TranslationData.allKeys[i]] = text;
                    }
                    currentLanguageAssetRef = assetRef;
                    onComplete?.Invoke(operation.Result);
                }
                else
                {
                    onComplete?.Invoke(null);
                }
            };
        }
    }
}
</file>

<file path="Translations/TranslationManager.cs.meta">
fileFormatVersion: 2
guid: 62bc73993c7808f47b9ec3049ccf8dd9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

<file path="Translations/Translations.cs">
namespace PSS
{
    public static class Translations
    {
        public static string Translate(string key)
        {
            return TranslationManager.Translate(key);
        }
    }
}
</file>

<file path="Translations/Translations.cs.meta">
fileFormatVersion: 2
guid: e9cf51b79f7d94342ae1611d7c2f4a17
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
</file>

</files>
